{-
Brendan Fallon
fallonbr
November 3, 2021

Question Fully Completed
Questions Partially Completed

-}
-- TODO remove HIDs

module Exercises.Lambda where


-- Library
open import Data.Bool using (T; not)
open import Data.String using (String; _â‰Ÿ_)
open import Data.Nat using (â„•; zero; suc)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Relation.Nullary using (Dec; yes; no; Â¬_)
open import Relation.Nullary.Decidable using (âŒŠ_âŒ‹; False; toWitnessFalse)
open import Relation.Nullary.Negation using (Â¬?)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; _â‰¢_; refl)

open import Isomorphism using (_â‰²_)  -- \ < ~ (tilde)
open import Lambda

-- 747/PLFA exercise: NatMul (1 point)
-- Write multiplication for natural numbers.
-- Alas, refinement will not help, and there is no way (yet) to write tests.

-- following same form as plus but different cases

mul : Term 
mul = Î¼ "*" â‡’ Æ› "m" â‡’ Æ› "n" â‡’
         case ` "m"
           [zeroâ‡’ `zero
           |suc "m" â‡’ `suc (` "*" Â· ` "m" Â· ` "n") ]

-- to implement this we would do
2*2 : Term
2*2 = mul Â· two Â· two

-- mul successfully implemented
           
-- 747/PLFA exercise: ChurchMul (1 point)
-- Write multiplication for Church numbers.
-- Use of plusá¶œ is optional! fixpoint is not needed.

-- This answer based on the Wikipedia page for Church Encoding
-- Source: https://en.wikipedia.org/wiki/Church_encoding#Calculation_with_Church_numerals
-- Uses identity f^âˆ˜(m*n) (x) = (f^âˆ˜n)^âˆ˜m (x)
-- mult â‰¡ Î»m.Î»n.Î»f.Î»x.m (n f) x where f is suc and x is zero

mulá¶œ : Term
mulá¶œ = Æ› "m" â‡’ Æ› "n" â‡’ Æ› "s" â‡’ Æ› "z" â‡’
         ` "m" Â· (` "n" Â· ` "s") Â· ` "z"

-- this would be implemented as
fourá¶œâ€² : Term
fourá¶œâ€² = mulá¶œ Â· twoá¶œ Â· twoá¶œ

-- ChurchMul/mulá¶œ has been successfully implemented 

-- PLFA exercise: use the new notation to define multiplication.

-- 747/PLFA exercise: StepEmbedsIntoStepPrime (2 points)
-- Show that the first definition embeds into the second.
-- Why is it not an isomorphism?

-- what is this steps? Are we using that counting thing?

ms1â‰¤ms2 : âˆ€ {M N} â†’ (M â€”â†  N) â‰² (M â€”â† â€² N)
_â‰²_.to ms1â‰¤ms2 Mâ€”â† N = {!!}
_â‰²_.from ms1â‰¤ms2 Mâ€”â† Nâ€² = {!!}
_â‰²_.fromâˆ˜to ms1â‰¤ms2 Mâ€”â† N = {!!}

ms1â‰¤ms2â€² : âˆ€ {M N} â†’ (M â€”â†  N) â‰² (M â€”â† â€² N)
ms1â‰¤ms2â€² = record {
         to = Î» x â†’ {!!} ;
         from = {!!} ;
         fromâˆ˜to = {!!}
         }


-- PLFA exercise: write out the reduction sequence showing one plus one is two.

-- 747/PLFA exercise: MulTyped (2 points)
-- Show that your mul above is well-typed.

âŠ¢mul : âˆ€ {Î“} â†’ Î“ âŠ¢ mul â¦‚ `â„• â‡’ `â„• â‡’ `â„•
âŠ¢mul = {!!}

-- 747/PLFA exercise: MulCTyped (2 points)
-- Show that your mulá¶œ above is well-typed.

âŠ¢mulá¶œ : âˆ€ {Î“ A} â†’ Î“  âŠ¢ mulá¶œ â¦‚ Ch A â‡’ Ch A â‡’ Ch A
âŠ¢mulá¶œ = {!!}

-- Unicode:

{-
â‡’  U+21D2  RIGHTWARDS DOUBLE ARROW (\=>)
Æ›  U+019B  LATIN SMALL LETTER LAMBDA WITH STROKE (\Gl-)
Â·  U+00B7  MIDDLE DOT (\cdot)
â€”  U+2014  EM DASH (\em)
â†   U+21A0  RIGHTWARDS TWO HEADED ARROW (\rr-)
Î¾  U+03BE  GREEK SMALL LETTER XI (\Gx or \xi)
Î²  U+03B2  GREEK SMALL LETTER BETA (\Gb or \beta)
âˆ‹  U+220B  CONTAINS AS MEMBER (\ni)
âˆ…  U+2205  EMPTY SET (\0)
âŠ¢  U+22A2  RIGHT TACK (\vdash or \|-)
â¦‚  U+2982  Z NOTATION TYPE COLON (\:)
ðŸ˜‡  U+1F607  SMILING FACE WITH HALO
ðŸ˜ˆ  U+1F608  SMILING FACE WITH HORNS

-}
